# Lesson 02: 双方向チャット

## 学習目標

このレッスンでは、`select()`システムコールを使用して、サーバーとクライアント間で**双方向にメッセージをやり取り**できるチャットプログラムを作成します。

Lesson 01のエコーサーバーでは、クライアントが送信→サーバーが応答という一方向の流れでした。
このレッスンでは、サーバーとクライアントの**どちらからでも**メッセージを送れるようになります。

## 前提知識

- Lesson 01（エコーサーバー）を完了していること
- socket(), bind(), listen(), accept(), connect(), send(), recv() の基本を理解していること

## 新しく学ぶAPI

| 関数 | 役割 | 使用例 |
|------|------|--------|
| `select()` | 複数のファイルディスクリプタを監視 | `select(maxfd+1, &readfds, NULL, NULL, NULL)` |
| `FD_ZERO()` | fd_setを初期化 | `FD_ZERO(&readfds)` |
| `FD_SET()` | fd_setにfdを追加 | `FD_SET(sockfd, &readfds)` |
| `FD_ISSET()` | fdがセットされているか確認 | `if (FD_ISSET(sockfd, &readfds))` |

## select()とは？

`select()`は、複数の入力元（ソケット、標準入力など）を**同時に監視**できるシステムコールです。

### なぜselect()が必要か？

通常の`recv()`や`fgets()`は**ブロッキング**します。つまり、データが来るまでプログラムが停止します。

```
問題: recv()でソケットを待っている間、キーボード入力を受け付けられない
      fgets()でキーボードを待っている間、ソケットからのメッセージを受け取れない
```

`select()`を使うと、「ソケットにデータが来た」または「キーボード入力があった」のどちらかが発生したときに処理を行えます。

### select()の動作イメージ

```
┌─────────────────────────────────────────────────────────┐
│                    select() が監視                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   標準入力 (fd=0)  ─────┐                               │
│                         │                               │
│   ソケット (fd=4)  ─────┼──→ どれかが読み込み可能に     │
│                         │      なったら select() が     │
│   他のソケット...  ─────┘      リターン                 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## ファイル構成

```
lessons/02-chat/
├── README.md           # このファイル
├── Makefile            # ビルド設定
├── server.cpp          # チャットサーバー
├── client.cpp          # チャットクライアント
└── expected_output.txt # 期待される出力例
```

## ビルドと実行

### 1. ビルド

```bash
cd lessons/02-chat
make
```

### 2. サーバーを起動（ターミナル1）

```bash
./server
```

出力例:
```
サーバーを起動しました。ポート 8080 で接続を待っています...
```

### 3. クライアントを接続（ターミナル2）

```bash
./client
```

出力例:
```
サーバーに接続しました (127.0.0.1:8080)
メッセージを入力してください（終了するには 'quit' と入力）:
```

### 4. 双方向でメッセージをやり取り

**クライアント側でメッセージを入力:**
```
> こんにちは
```

**サーバー側に表示される:**
```
クライアント: こんにちは
```

**サーバー側でメッセージを入力:**
```
> やあ、元気？
```

**クライアント側に表示される:**
```
サーバー: やあ、元気？
```

### 5. 終了

どちらかで `quit` と入力するか、Ctrl+C で終了します。

## 演習問題

1. **複数クライアント対応**: 現在のサーバーは1クライアントのみ対応しています。
   複数のクライアントを同時に接続できるように拡張してみましょう。
   ヒント: 接続済みクライアントのリストを管理し、select()で全てを監視します。

2. **タイムアウト機能**: select()の第5引数（タイムアウト）を使って、
   一定時間入力がなければ自動切断する機能を追加してみましょう。

3. **ニックネーム機能**: 接続時にニックネームを設定し、
   メッセージに送信者名を表示するようにしてみましょう。

## トラブルシューティング

### "Address already in use" エラー

前回のサーバープロセスがまだポートを使用しています。

```bash
# ポート8080を使用しているプロセスを確認
lsof -i :8080

# プロセスを終了（PIDは上記コマンドで確認）
kill <PID>
```

### クライアントからのメッセージがサーバーに届かない

1. サーバーが起動していることを確認
2. ファイアウォールの設定を確認
3. 正しいIPアドレスとポートを使用しているか確認

### 日本語が文字化けする

ターミナルのエンコーディングがUTF-8になっているか確認してください。

## 次のステップ

Lesson 03では、Wiresharkを使用してTCP/IP通信のパケットを解析し、
3ウェイハンドシェイクやデータパケットの流れを視覚的に理解します。
